\doxysection{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\mbox{\hyperlink{classActivationFunc}{Activation\+Func}} \\*The activation function class }{\pageref{classActivationFunc}}{}
\item\contentsline{section}{\mbox{\hyperlink{classAsmParser}{Asm\+Parser}} \\*A parser to convert assembly into a neural network input by just taking the binary values }{\pageref{classAsmParser}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBinaryParser}{Binary\+Parser}} \\*A parser to convert assembly into a neural network input by splitting each instruction with a 0.\+5 }{\pageref{classBinaryParser}}{}
\item\contentsline{section}{\mbox{\hyperlink{classBinaryWithSplitParser}{Binary\+With\+Split\+Parser}} \\*A parser to convert binary into a neural network input by splitting each instruction with a 0.\+5 }{\pageref{classBinaryWithSplitParser}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCyclesBoundedNormaliserEncoder}{Cycles\+Bounded\+Normaliser\+Encoder}} \\*A class to encode and decode the number of cycles by normalising it, but between 0.\+15 and 0.\+85 to avoid either very low or very high values }{\pageref{classCyclesBoundedNormaliserEncoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCyclesLogEncoder}{Cycles\+Log\+Encoder}} \\*A class to encode and decode the number of cycles by normalising it in a logarithmic scale }{\pageref{classCyclesLogEncoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCyclesNormaliserEncoder}{Cycles\+Normaliser\+Encoder}} \\*A class to encode and decode the number of cycles by normalising it (dividing by the maximum number of cycles), to have a value between 0 and 1 }{\pageref{classCyclesNormaliserEncoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCyclesSplitterEncoder}{Cycles\+Splitter\+Encoder}} \\*A class to encode and decode the number of cycles by splitting it into 4 values, billions, millions, thousands and units }{\pageref{classCyclesSplitterEncoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{classCyclesSqrtEncoder}{Cycles\+Sqrt\+Encoder}} \\*A class to encode and decode the number of cycles by using the square root of the value }{\pageref{classCyclesSqrtEncoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{classDataset}{Dataset}} \\*Class representing a dataset (inputs and outputs) }{\pageref{classDataset}}{}
\item\contentsline{section}{\mbox{\hyperlink{classELU}{ELU}} \\*The e\+LU activation function }{\pageref{classELU}}{}
\item\contentsline{section}{\mbox{\hyperlink{classGELU}{GELU}} \\*The \doxylink{classGELU}{GELU} activation function }{\pageref{classGELU}}{}
\item\contentsline{section}{\mbox{\hyperlink{classHexadecimalParser}{Hexadecimal\+Parser}} \\*A parser to convert assembly into a neural network input by splitting each instruction with a 0.\+5 }{\pageref{classHexadecimalParser}}{}
\item\contentsline{section}{\mbox{\hyperlink{classHexadecimalWithSplitParser}{Hexadecimal\+With\+Split\+Parser}} \\*A parser to convert hexadecimal into a neural network input by splitting each instruction with a 1.\+0 }{\pageref{classHexadecimalWithSplitParser}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIEncoder}{IEncoder}} \\*Interface for encoding and decoding data }{\pageref{classIEncoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{classIParser}{IParser}} \\*Interface for parsing and transforming assembly instructions into an input for a neural network }{\pageref{classIParser}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLayer}{Layer}} \\*Class representing a neural network layer }{\pageref{classLayer}}{}
\item\contentsline{section}{\mbox{\hyperlink{classLeakyReLU}{Leaky\+Re\+LU}} \\*The Leaky \doxylink{classReLU}{Re\+LU} activation function }{\pageref{classLeakyReLU}}{}
\item\contentsline{section}{\mbox{\hyperlink{classNeuralNetwork}{Neural\+Network}} \\*Class representing a neural network }{\pageref{classNeuralNetwork}}{}
\item\contentsline{section}{\mbox{\hyperlink{classNonEncoder}{Non\+Encoder}} \\*An encoder that does not transform the input }{\pageref{classNonEncoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{structPlanet}{Planet}} }{\pageref{structPlanet}}{}
\item\contentsline{section}{\mbox{\hyperlink{classReLU}{Re\+LU}} \\*The \doxylink{classReLU}{Re\+LU} activation function }{\pageref{classReLU}}{}
\item\contentsline{section}{\mbox{\hyperlink{structSha256Context}{Sha256\+Context}} }{\pageref{structSha256Context}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSigmoid}{Sigmoid}} \\*The sigmoid activation function }{\pageref{classSigmoid}}{}
\item\contentsline{section}{\mbox{\hyperlink{classSizeEncoder}{Size\+Encoder}} \\*A class to encode and decode a variable size vector }{\pageref{classSizeEncoder}}{}
\item\contentsline{section}{\mbox{\hyperlink{classTanh}{Tanh}} \\*The tanh activation function }{\pageref{classTanh}}{}
\item\contentsline{section}{\mbox{\hyperlink{classXORParser}{XORParser}} \\*A parser for the XOR data for a neural network }{\pageref{classXORParser}}{}
\end{DoxyCompactList}
